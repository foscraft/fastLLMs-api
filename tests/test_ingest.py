# Generated by CodiumAI
from xml.dom.minidom import Document

import pytest


class TestCodeUnderTest:
    # Load documents from source directory and split into chunks of text
    def test_load_documents_and_split_chunks(self, mocker):
        # Mock the necessary dependencies
        mocker.patch("glob.glob", return_value=["file1.csv", "file2.txt"])
        mocker.patch("os.path.join", return_value="source_directory/file1.csv")
        mocker.patch("os.cpu_count", return_value=4)
        mocker.patch("tqdm.tqdm")

        # Mock the loader class and its load method
        class MockLoader:
            def __init__(self, file_path):
                self.file_path = file_path

            def load(self):
                return [Document(text="document1"), Document(text="document2")]

        mocker.patch("code_under_test.LOADER_MAPPING", {".csv": (MockLoader, {})})

        # Call the function under test
        result = code_under_test.load_documents("source_directory")

        # Assert the expected result
        assert result == [Document(text="document1"), Document(text="document2")]

    # Create embeddings and check if vectorstore exists
    def test_create_embeddings_and_check_vectorstore_exists(self, mocker):
        # Mock the necessary dependencies
        mocker.patch("os.path.exists", return_value=True)
        mocker.patch("os.path.join")
        mocker.patch("glob.glob", return_value=["index/file1.bin", "index/file2.pkl"])
        mocker.patch("code_under_test.Chroma")

        # Call the function under test
        result = code_under_test.does_vectorstore_exist("persist_directory")

        # Assert the expected result
        assert result is True

    # Append to existing vectorstore if it exists
    def test_append_to_existing_vectorstore(self, mocker):
        # Mock the necessary dependencies
        mocker.patch("os.path.exists", return_value=True)
        mocker.patch("os.path.join")
        mocker.patch("glob.glob", return_value=["index/file1.bin", "index/file2.pkl"])
        mocker.patch("code_under_test.Chroma")
        mocker.patch(
            "code_under_test.process_documents",
            return_value=[Document(text="document1"), Document(text="document2")],
        )

        # Call the function under test
        code_under_test.main()

        # Assert that Chroma.add_documents is called
        code_under_test.Chroma.return_value.add_documents.assert_called_with(
            [Document(text="document1"), Document(text="document2")]
        )

    # Unsupported file extension raises ValueError
    def test_unsupported_file_extension_raises_value_error(self):
        # Call the function under test and assert that it raises a ValueError
        with pytest.raises(ValueError):
            code_under_test.load_single_document("file1.jpg")

    # Error in loading a document raises an exception with file_path
    def test_error_in_loading_document_raises_exception_with_file_path(self, mocker):
        # Mock the necessary dependencies
        mocker.patch(
            "code_under_test.UnstructuredEmailLoader.load",
            side_effect=ValueError("text/html content not found in email"),
        )
        mocker.patch(
            "code_under_test.UnstructuredEmailLoader",
            side_effect=code_under_test.UnstructuredEmailLoader,
        )

        # Call the function under test and assert that it raises an exception with the file_path
        with pytest.raises(ValueError) as e:
            code_under_test.load_single_document("file1.eml")
        assert str(e.value) == "file1.eml: text/html content not found in email"

    # No new documents to load exits program
    def test_no_new_documents_to_load_exits_program(self, mocker, capsys):
        # Mock the necessary dependencies
        mocker.patch("code_under_test.load_documents", return_value=[])

        # Call the function under test
        code_under_test.main()

        # Assert that the program exits with code 0 and prints the expected message
        captured = capsys.readouterr()
        assert captured.out == "No new documents to load\n"
        assert captured.err == ""
        assert capsys.exit.called_with(0)
